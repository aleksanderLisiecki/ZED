---
title: "projekt_ZED"
author: "Aleksander Lisiecki"
date: "`r format(Sys.time(), '%d %B %Y')`"
output: 
  html_document: 
    toc: true
    toc_float:
      collapsed: true
    toc_depth: 5
    theme: united
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(message = FALSE)
knitr::opts_chunk$set(warning = FALSE)
```

***
### Użyte biblioteki
***

```{r}
library(dplyr)
library(plotly)
library(ggplot2)
library(readxl)
library(tidyr)
library(knitr)
library(kableExtra)
library(TTR)
library(data.table)
library(caret)

set.seed(23)
```

***
### Gold Prices
***

#### Wczytywanie i czyszczenie danych:

* nadanie właściwych typów danych,
* pozostawienie do dalszych rozważań jedynie ceny w walucie USD,
* zmiana nazw kolumn dla AM and PM fixing,

```{r, cache=TRUE}
Gold.prices <- read.csv("C:/Users/alili/Desktop/studia/9 semestr/ZED/projekt/Data pack/Gold prices.csv", 
                        colClasses = c(rep("Date", 1),
                                       rep("numeric", 2),
                                       rep("NULL", 4)),
                        col.names = c('Date',
                                      'Morning.Fix.USD',
                                      'Afternoon.Fix.USD',
                                      rep("NULL", 4)),
                        header = TRUE)
```

* uzupełnijnie brakujących wartości (NA) w kolumnach z ceną otwarcia i zamknięcia, wartością z sąsiedniej kolumny (w całym zbiorze nie ma sytuacji gdzie brakują obydwie)
* dodanie kolumny USD z uśrednioną ceną otwarcia i zamknięcia

```{r}
Gold.prices <- Gold.prices %>% 
  mutate(Morning.Fix.USD = coalesce(Morning.Fix.USD, Afternoon.Fix.USD),
         Afternoon.Fix.USD = coalesce(Afternoon.Fix.USD, Morning.Fix.USD),
         USD = (Morning.Fix.USD + Afternoon.Fix.USD) / 2)
```

* utworzenie zbioru ze średnią roczną ceną złota

```{r}
Gold.prices.yearly <- Gold.prices %>%
  mutate(Year = as.numeric(substr(Date, 1, 4))) %>%
  group_by(Year) %>% 
  summarize( USD = (mean(Morning.Fix.USD) + mean(Afternoon.Fix.USD)) / 2)
```


#### Podsumowanie danych:

Zbiór zawiera codzienne wyceny złota podczas sesji otwarcia i zamknięcia od dnia 1968-01-02 do 2021-09-29.

```{r}
head(Gold.prices) %>% 
  kable() %>%
  kable_styling("striped", full_width = F, position = 'left')

data.frame(nrow(Gold.prices)) %>%
  rename("Liczba próbek" = 1) %>%
  kable() %>%
  kable_styling(full_width = FALSE, position = 'left')

summary(Gold.prices) %>%
  kable() %>%
  kable_styling("striped", full_width = F, position = 'left')
```

#### Analiza wartości ceny złota

Na interaktywnym wykresie widzimy zmianę cen otwarcia w czasie.

```{r, fig.width=9,fig.height=6}
p <- ggplot(Gold.prices, aes(x = Date)) +
  geom_point(aes(y = USD), color = "gold")

ggplotly(p)
```

***
### World development indicators (WDI)
***

#### Wczytywanie zbioru danych

* podczas wczytywania uwzględniane są znaki wartości pustych w zbiorze
* pozbycie się informacji o źródle pochodzenia zbioru poprzez podanie zakresu czytania zbioru

```{r}
World_Development_Indicators <- read_excel("C:/Users/alili/Desktop/studia/9 semestr/ZED/projekt/Data pack/World_Development_Indicators.xlsx", 
                                           na = '..', 
                                           range = "A1:BC44305")
```

#### Czyszczenie zbioru:

* usunięcie elementów innych niż kraje z kolumny `Country Name`, pozostawienie statystyk dla całego swiata w zbiorze krajów, 

```{r}
World_Development_Indicators <- World_Development_Indicators %>%
  filter(!`Country Name` %in% c("Low & middle income","Low income","Lower middle income","Middle income","Upper middle income","High income"))
```


* wyodrębnienie kodów serii do osobnej tabeli oraz usunięcie jej z przetwarzanego zbioru,
```{r}
World_Development_Indicators.Series_Codes <- select(World_Development_Indicators, `Series Name`, `Series Code`)
World_Development_Indicators <- select(World_Development_Indicators, -`Series Code`)
```

* przeniesienie pojedyńczych obserwacji do osobnych wierszy

```{r}
World_Development_Indicators <- World_Development_Indicators %>%
  pivot_longer(cols = `1970 [YR1970]`:`2020 [YR2020]`, names_to = "Year") %>%
  group_by(`Series Name`) %>%
  mutate(row = row_number()) %>%
  tidyr::pivot_wider(names_from = `Series Name`, values_from = value) %>%
  select(-row)
```

* poprawa kolumny Year: wyodrębnienie lat jako numerycznych wartości

```{r}
World_Development_Indicators <- World_Development_Indicators %>%
  mutate(Year = as.numeric(substr(Year, 1, 4)))
```

#### Podsumowanie danych:

* liczba różnych wskaźników

```{r}
country.count <- length(unique(World_Development_Indicators$`Country Name`)) - 1
indicators.count <- World_Development_Indicators %>%
  select(-`Country Name`, -`Country Code`, -Year) %>%
  ncol
  
WDI_summary <- data.frame(country.count, indicators.count) %>%
  rename("Liczba krajów" = country.count,
         "Liczba wskaźników" = indicators.count)

kable(WDI_summary) %>%
  kable_styling(full_width = FALSE, position = 'left')
```


:::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px; "}

::: {}

```{r, echo=FALSE}
World_Development_Indicators$`Country Name` %>%
  unique %>%
  data.frame() %>%
  rename('Lista krajów dostępnych w zbiorze' = '.') %>%
  kable() %>%
  kable_styling("striped", full_width = F, position = 'left') %>%
  scroll_box( height = '400px')
```

:::

::: {}

```{r, echo=FALSE}
World_Development_Indicators %>%
  names %>%
  data.frame() %>%
  rename('Lista dostępnych wskaźników' = '.') %>%
  kable %>%
  kable_styling("striped", full_width = F, position = 'left') %>%
  scroll_box(width = '650px', height = '400px')
```

:::

::::



***
### S&P Composite
***

#### Wczytywanie danych

```{r}
SP.Composite <- read.csv("C:/Users/alili/Desktop/studia/9 semestr/ZED/projekt/Data pack/S&P Composite.csv")
```

#### Czyszczenie danych:

* zmiana nazwy oraz typ na właściwy kolumny z datą
* zmiana nazwy Cyclicaly.Adjusted.PE.Ratio na skrót CAPE -

```{r}
SP.Composite <- SP.Composite %>%
  rename(Date = Year,
         CAPE = Cyclically.Adjusted.PE.Ratio) %>%
  mutate(Date = as.Date(Date))
```

#### Znaczenie atrybutów:

* S.P.Composite - nominalna wartość indexu,
* Divident - nominalna dywidenta,
* Earnings - nominalne zarobki na indeksie,
* CPI - wskaźnik cen towarów i usług konsumpcyjnych. Najpopularniejsza na świecie miara inflacji/deflacji,
* Long.Interest.Rate - stopy procentowe dziesięcioletnich obligacji rządowych,
* Real.Price - realna wartość indexu,
* Real.Divident - realna dywidenta,
* Real.Earnings - realne zarobki na indeksie,
* CAPE (Cyclicaly.Adjusted.PE.Ratio) - cyklicznie dostosowywany wskaźnik ceny do zysków. Definiuje się go jako cenę podzieloną przez średnią z dziesięciu lat zarobków, skorygowaną o inflację.

#### Podsumowanie danych

```{r}
head(SP.Composite) %>% 
  kable() %>%
  kable_styling("striped", full_width = F, position = 'left') %>%
  scroll_box( width = '100%')

data.frame(nrow(Gold.prices)) %>%
  rename("Liczba próbek" = 1) %>%
  kable() %>%
  kable_styling(full_width = FALSE, position = 'left')

summary(SP.Composite) %>%
  kable() %>%
  kable_styling(bootstrap_options = c("striped", "hover"), position = 'left') %>%
  scroll_box( width = '100%')
```

***
### Currency Exchange Rates
***

#### Wczytywanie danych:

```{r, cache=TRUE}
Currency.Exchange.Rates <- read.csv("C:/Users/alili/Desktop/studia/9 semestr/ZED/projekt/Data pack/CurrencyExchangeRates.csv")
```

#### Czyszczenie danych:

* zmiana typu kolumny z datą

```{r}
Currency.Exchange.Rates <- Currency.Exchange.Rates %>% 
  mutate(Date = as.Date(Date))
```

#### Podsumowanie danych:

Zbiór zawiera codzienny kurs wymiany walut od dnia 1995-01-02 do 2018-05-02.

```{r}
Currency.Exchange.Rates %>%
  names %>%
  data.frame() %>%
  rename('Dostępne waluty' = '.') %>%
  kable %>%
  kable_styling("striped", full_width = F, position = 'left') %>%
  scroll_box(width = '400px', height = '400px')

```

***
### Bitcoin dataset
***

#### Wczytywanie danych:

```{r, cache=TRUE}
Bitcoin.prices <- read.csv("C:/Users/alili/Desktop/studia/9 semestr/ZED/projekt/Data pack/Bitcoin/BCHAIN-MKPRU.csv",
                           colClasses = c(rep("Date", 1),
                                       rep("numeric", 1)),
                           col.names = c('Date',
                                      'USD'))

Bitcoin.trade.volume <- read.csv("C:/Users/alili/Desktop/studia/9 semestr/ZED/projekt/Data pack/Bitcoin/BCHAIN-TRVOU.csv",
                           colClasses = c(rep("Date", 1),
                                       rep("numeric", 1)),
                           col.names = c('Date',
                                      'Trade Volume'))

Bitcoin.mine.difficulty <- read.csv("C:/Users/alili/Desktop/studia/9 semestr/ZED/projekt/Data pack/Bitcoin/BCHAIN-DIFF.csv",
                           colClasses = c(rep("Date", 1),
                                       rep("numeric", 1)),
                           col.names = c('Date',
                                      'Mine difficulty'))

Bitcoin.hash.rate <- read.csv("C:/Users/alili/Desktop/studia/9 semestr/ZED/projekt/Data pack/Bitcoin/BCHAIN-HRATE.csv",
                           colClasses = c(rep("Date", 1),
                                       rep("numeric", 1)),
                           col.names = c('Date',
                                      'Hash rate'))
Bitcoin <- Bitcoin.prices %>%
  merge(Bitcoin.trade.volume, by = "Date") %>%
  merge(Bitcoin.mine.difficulty, by = "Date") %>%
  merge(Bitcoin.hash.rate, by = "Date")
  
```


#### Podsumowanie danych:

Zestaw danych zawiera codzienne informacje od początku istnienia Bitcoina.

Znaczenie atrybutów:
* USD - Bitcoin Market Price USD,Average USD market price across major bitcoin exchanges.
* Trade volume - Bitcoin USD Exchange Trade Volume,The total USD value of trading volume on major bitcoin exchanges.
* Mine difficulty - Bitcoin Difficulty,A relative measure of how difficult it is to find a new block. The difficulty is adjusted periodically as a function of how much hashing power has been deployed by the network of miners.
* Hash rate - Bitcoin Hash Rate,The estimated number of tera hashes per second (trillions of hashes per second) the Bitcoin network is performing.




```{r}
tail(Bitcoin)
summary(Bitcoin)
```


***
***

### Analizy:

***

#### Animowany wykres zmiany liczby ludności w czasie (Odpalić z puszczoną w tle piosenką Queen "Another One Bites the Dust"):

```{r, cache = TRUE, echo=FALSE, message=FALSE, warning=FALSE, fig.width=9,fig.height=6}
specify_decimal <- function(x, k) trimws(format(round(x, k), nsmall=k))

World.Population.Top10 <- World_Development_Indicators %>%
  filter(`Country Name` != "World") %>%
  rename(Population = `Population, total`) %>%
  select(`Country Name`, Year, Population) %>%
  group_by(Year) %>%
  arrange(desc(Population), .by_group = T) %>%
  top_n(11) %>%
  mutate(`Population in mln` = Population/10^6, Rank = rank(Population))

p <- World.Population.Top10 %>%
  ggplot(aes(Rank, Population, fill = `Country Name`)) +
  geom_col(aes(frame = Year), position = "identity") +
  geom_text(aes(frame = Year, y = Population + 1.5*10^8, label = paste0(round(`Population in mln`,2), 'mln')), hjust = 0) +
  geom_text(aes(frame = Year, y = `Population in mln`/2, label = `Country Name`), hjust = 0) +
  ylim(-10^8,1.6*10^9) +
  coord_flip() +
  theme_bw() +
  ggtitle("Populacja świata w latach 1970-2020") +
  theme(axis.line=element_blank(),
        axis.text.x=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        legend.position="none",
        plot.title=element_text(size=22, hjust=0.5, face="bold", colour="grey")) 

ggplotly(p)
```

```{r}
World.Population.Top10 
```

***

#### Samobójstwa kobiet i mężczyzn na świecie w latach 2000-2019:

```{r, echo=FALSE, message=FALSE, warning=FALSE}

suicides <- World_Development_Indicators %>%
  filter(`Country Name` == 'World') %>%
  select(Year, `Suicide mortality rate, female (per 100,000 female population)`, `Suicide mortality rate, male (per 100,000 male population)`) %>%
  filter(!is.na(`Suicide mortality rate, female (per 100,000 female population)`))

suicides.male <- suicides %>%
  select(Year, `Suicide mortality rate, male (per 100,000 male population)`) %>%
  rename(`Suicide mortality rate (per 100,000 of given gender population)` = `Suicide mortality rate, male (per 100,000 male population)`) %>%
  mutate(gender = 'male')

suicides.female <- suicides %>%
  select(Year, `Suicide mortality rate, female (per 100,000 female population)`) %>%
  rename(`Suicide mortality rate (per 100,000 of given gender population)` = `Suicide mortality rate, female (per 100,000 female population)`) %>%
  mutate(gender = 'female')

suicides.per.gender <- rbind.data.frame(suicides.male, suicides.female)

suicides.per.gender %>%
  ggplot(aes(x = Year, y = `Suicide mortality rate (per 100,000 of given gender population)`)) +
  geom_line(aes(colour = gender), size = 1) +
  geom_point(colour = 'royalblue', size = 2) +
  expand_limits(y = 0) +
  ggtitle('Współczynnik samobójstw (na 100,000 osób danej płci)') +
  ylab('') +
  theme_bw() -> p
  ggplotly(p)

```

Wniosek: 
Liczba samobójstw jest w trendzie spadkowym, zdrowie psychiczne ludzkości się polepsza.  

***

#### Korelacja ceny złota do ceny BTC:

```{r}
gold <- Gold.prices %>%
  select(Date, USD) %>%
  arrange(desc(row_number())) %>%
  filter( Date < '2021-09-29') %>%
  filter( Date > '2016-01-01') %>%
  rename( USD.gold = USD )

BTC_price <- Bitcoin.prices %>%
  arrange(desc(row_number())) %>%
  filter( Date < '2021-09-29') %>%
  filter( Date > '2016-01-01') %>%
  rename( USD.BTC = USD )

gold.btc <- gold %>%
  inner_join(BTC_price, by = 'Date')


cor.gold.btc <- cor(gold.btc$USD.gold, gold.btc$USD.BTC, use = "complete.obs")

coeff.gold.btc <- max(gold.btc$USD.BTC)/max(gold.btc$USD.gold)

gold.btc %>%
  ggplot( aes(x = Date) ) +
  geom_line( aes(y = USD.gold), color = 'gold' ) +
  geom_line( aes(y = USD.BTC/coeff.gold.btc), color = 'orange' ) + 
  scale_y_continuous(
    name = "Cena złota",
    sec.axis = sec_axis(~.*coeff.gold.btc, name="Cena BTC")
  ) +
  ggtitle("Cena złota oraz BTC [USD]") +
  theme_bw() + 
  theme(
    axis.title.y = element_text(color = 'gold', size=13),
    axis.title.y.right = element_text(color = 'orange', size=13),
    axis.text.y = element_text(color = 'gold', size=13),
    axis.text.y.right = element_text(color = 'orange', size=13)
  )
```

Wniosek:
Pomimo korelacji na poziomie 0.68 wizualna inspekcja nie pokazuje jasnej zależności pomiędzy cenami porównywanych aktywów.


#### Korelacja złota oraz BTC z indexem S&P Composite

```{r}
Gold.prices.monthly <- Gold.prices %>%
  mutate(Date = substr(Date, 1, 7)) %>%
  group_by(Date) %>% 
  summarize( USD = (mean(Morning.Fix.USD) + mean(Afternoon.Fix.USD)) / 2)

SP.df <- SP.Composite %>%
  mutate(Date = substr(Date, 1, 7)) %>%
  select(Date, S.P.Composite)

gold.SP <- Gold.prices.monthly %>%
  inner_join(SP.df, by = 'Date') %>%
  mutate(Date = as.Date(paste0(Date,'-01')))

cor(gold.SP$USD, gold.SP$S.P.Composite, use = "complete.obs")

coeff.gold.SP <- max(gold.SP$S.P.Composite)/max(gold.SP$USD)

gold.SP %>%
  ggplot( aes(x = Date) ) +
  geom_line( aes(y = USD), color = 'gold' ) +
  geom_line( aes(y = S.P.Composite/coeff.gold.SP), color = 'royalblue' ) + 
  scale_y_continuous(
    name = "Cena złota",
    sec.axis = sec_axis(~.*coeff.gold.SP, name="Cena S&P Composite")
  ) +
  ggtitle("Cena złota oraz indeksu S&P Composite [USD]") +
  theme_bw() + 
  theme(
    axis.title.y = element_text(color = 'gold', size=13),
    axis.title.y.right = element_text(color = 'royalblue', size=13),
    axis.text.y = element_text(color = 'gold', size=13),
    axis.text.y.right = element_text(color = 'royalblue', size=13)
  )
```

Wniosek:
Pomimo korelacji na poziomie 0.82 wizualna inspekcja nie pokazuje jasnej zależności pomiędzy cenami porównywanych aktywów.

***

#### Zbadanie najwyższych korelacji wskaźników rozwoju USA z ceną złota.

```{r}
USA.WDI <- World_Development_Indicators %>%
  filter(`Country Name` == 'United States') %>%
  merge(Gold.prices.yearly, by = 'Year') %>%
  select_if(~ !any(is.na(.)))
  
USA.WDI.to_cor <- USA.WDI %>%
  select(-(1:3))

num_col=ncol(USA.WDI.to_cor[,-1])
out_indx <-  which(upper.tri(diag(num_col))) 
cor_cols <- USA.WDI.to_cor  %>%
            do(melt(cor(.[,-1], use="pairwise.complete.obs"), value.name="cor")[out_indx,])

cor_cols <- cor_cols %>%
  filter(Var2 == 'USD') %>%
  top_n(10) %>%
  arrange(desc(cor)) %>%
  rename(top_cor = cor)

cor_cols

```

```{r}
coeff.income_gold.price <- max(USA.WDI$`Net primary income (BoP, current US$)`)/max(USA.WDI$USD)

USA.WDI %>%
  ggplot( aes(x = Year) ) +
  geom_line( aes(y = USD), color = 'gold' ) +
  geom_line( aes(y = `Net primary income (BoP, current US$)`/coeff.income_gold.price), color = 'royalblue' ) + 
  scale_y_continuous(
    name = "Cena złota",
    sec.axis = sec_axis(~.*coeff.gold.SP, name="Net primary income")
  ) +
  ggtitle("Cena złota w porównaniu ze wskaźnikiem przychodu netto w USA") +
  theme_bw() + 
  theme(
    axis.title.y = element_text(color = 'gold', size=13),
    axis.title.y.right = element_text(color = 'royalblue', size=13),
    axis.text.y = element_text(color = 'gold', size=13),
    axis.text.y.right = element_text(color = 'royalblue', size=13)
  )
```

```{r}
coeff.service_export.price <- max(USA.WDI$`Service exports (BoP, current US$)`)/max(USA.WDI$USD)

USA.WDI %>%
  ggplot( aes(x = Year) ) +
  geom_line( aes(y = USD), color = 'gold' ) +
  geom_line( aes(y = `Service exports (BoP, current US$)` / coeff.service_export.price), color = 'royalblue' ) + 
  scale_y_continuous(
    name = "Cena złota",
    sec.axis = sec_axis(~.*coeff.gold.SP, name="Service exports")
  ) +
  ggtitle("Cena złota w porównaniu ze wskaźnikiem eksportu usług w USA") +
  theme_bw() + 
  theme(
    axis.title.y = element_text(color = 'gold', size=13),
    axis.title.y.right = element_text(color = 'royalblue', size=13),
    axis.text.y = element_text(color = 'gold', size=13),
    axis.text.y.right = element_text(color = 'royalblue', size=13)
  )
```

Wnioski: 
Wskaźniki WDI są podawane rok rocznie. Próba korelacji różnych wskaźników WDI z ceną złota wskazuje głównie na wzrost gospodarczy. W próbie przewidywania ceny złota w ujęciu rocznym nie widzę sensu ze względu na zbyt małą ilość danych. 

***

#### Próba stworzenia modelu do przewidywnaia dobrego momentu kupna i sprzedaży złota.

Zamiast przewidywać cenę złota, co w oparciu o posiadane dane będzie skazane na mizerny rezultat, stworzę model próbujący znaleźć w prostych wskaźnikach analizy technicznej dobre momenty do kupna lub sprzedaży złota.

Moja próba oparta bedzie o strategię średnich kroczących (ang. Moving averages). Metoda ta polega na obliczeniu średniej ceny złota z okresu czasu o długości n wstecz. 

Na podstawie wielu średnich kroczących stworzony zostanie klasyfikator próbujący przewidzieć dobry moment do kupna lub sprzedaży kruszca.


##### Zaznaczanie miejsc dobrych do kupna i sprzedaży

Pierwszym krokiem jest subiektywne zaznaczenie okresów w których warto było poszerzać oraz zawężać ekspozycję swojego portfela inwestycyjnego na złoto. 

```{}
Gold.prices %>% 
  mutate(exposition = 0) %>%
  write_xlsx("C:/Users/alili/Desktop/studia/9 semestr/ZED/projekt/Data pack/Gold_prices_to_mark_exposition.xlsx")
  
```

Odczytanie nowego zbioru:

```{r}
Gold.prices <- read_excel("C:/Users/alili/Desktop/studia/9 semestr/ZED/projekt/Data pack/Gold_prices_with_marked_exposition.xlsx")
```

Czyszczenie zbioru:

```{r}

positive.exposition <- Gold.prices$exposition
positive.exposition[Gold.prices$exposition == -1] <- 0

negative.exposition <- Gold.prices$exposition
negative.exposition[Gold.prices$exposition == 1] <- 0
negative.exposition[Gold.prices$exposition == -1] <- 1

Gold.prices <- Gold.prices %>%
  mutate('positive.exposition' = positive.exposition,
         'negative.exposition' = negative.exposition,)

```

Wykres przedstawiający miejsca kupna oraz sprzedaży:

```{r}
positive.diff <- diff(c(0, positive.exposition))
positive.starts <- Gold.prices$Date[positive.diff == 1]
positive.ends <- Gold.prices$Date[positive.diff == -1]
if (length(positive.starts) > length(positive.ends)) positive.ends <- c(positive.ends, tail(Gold.prices$Date, 1))

positive.sections <- data.frame(start=positive.starts, end=positive.ends, group=seq_along(positive.starts))


negative.diff <- diff(c(0, negative.exposition))
negative.starts <- Gold.prices$Date[negative.diff == 1]
negative.ends <- Gold.prices$Date[negative.diff == -1]
if (length(negative.starts) > length(negative.ends)) negative.ends <- c(negative.ends, tail(Gold.prices$Date, 1))

negative.sections <- data.frame(start=negative.starts, end=negative.ends, group=seq_along(negative.starts))

ggplot(data=Gold.prices, aes(Date, USD)) +
  theme_minimal() +
  geom_line(color = "gold") +
  geom_rect(data=positive.sections, inherit.aes=FALSE, aes(xmin=start, xmax=end, ymin=min(Gold.prices$value),
                ymax=max(Gold.prices$value), group=group), color="transparent", fill="green", alpha=0.4)+
  geom_rect(data=negative.sections, inherit.aes=FALSE, aes(xmin=start, xmax=end, ymin=min(Gold.prices$value),
                ymax=max(Gold.prices$value), group=group), color="transparent", fill="red", alpha=0.4)

```

Podsumowanie ilości dni dobrych do kupna oraz sprzedaży złota.

```{r}
positive.exposition.count <- data.frame(positive.exposition) %>%
  filter(positive.exposition > 0) %>%
  count() %>%
  rename("positive exposition" = n)

negative.exposition.count <- data.frame(negative.exposition) %>%
  filter(negative.exposition > 0) %>%
  count() %>%
  rename("negative exposition" = n)

data.frame(positive.exposition.count, negative.exposition.count) %>%
  print
```

Liczba miejsc do kupna jest znacznie wieksza niż miejsc do sprzedaży. Jest to spowodowane tym, że wzrost wartości złota jest powolny, a spadki szybkie.


Obliczanie średnich kroczących:

```{r}
df.to.model <- Gold.prices %>%
  arrange(desc(row_number())) %>%
  mutate(MA1 = SMA(USD, 1),
         MA3 = SMA(USD, 3),
         MA7 = SMA(USD, 7),
         MA11 = SMA(USD, 11),
         MA19 = SMA(USD, 19),
         MA27 = SMA(USD, 27),
         MA50 = SMA(USD, 50),
         MA100 = SMA(USD, 100),
         MA200 = SMA(USD, 200),
         MA365 = SMA(USD, 365),
         MA730 = SMA(USD, 730),
         MA1095 = SMA(USD, 1095)
         ) %>%
  filter_at(vars(-Date), all_vars(!is.na(.))) %>%
  select(-(Date:USD), -positive.exposition, -negative.exposition) %>%
  mutate(exposition = as.factor(exposition))
  
  
  
df.to.model <- Gold.prices %>%
  arrange(desc(row_number())) %>%
  mutate(MA1 = SMA(USD, 1),
         MA3 = SMA(USD, 3),
         MA7 = SMA(USD, 7),
         MA19 = SMA(USD, 19),
         MA50 = SMA(USD, 50),
         MA200 = SMA(USD, 200),
         MA1095 = SMA(USD, 1095)
         ) %>%
  filter_at(vars(-Date), all_vars(!is.na(.))) %>%
  select(-(Date:USD), -positive.exposition, -negative.exposition) %>%
  mutate(exposition = as.factor(exposition))

head(df.to.model)

  
```

Mmmm, jaki piękny zbiór na wykonanie modelu... już nie mogę się doczekać :3

```{}

ggplot(data=df.to.model, aes(Date)) +
  theme_minimal() +
  geom_line(aes(y=USD), color = "gold") +
  geom_line(aes(y=MA19), color = "black") +
  geom_line(aes(y=MA100), color = "black") +
  geom_line(aes(y=MA365), color = "black") 

```







***

#### Klasyfikator

Podzielenie zbioru na zbiór treningowy oraz testowy.
Zbiór nie jest dzielony w sposób losowy, aby zbiór testowy nie był podobny do zbioru treningowego.

```{r}
training_set_percentage <- 75

training <- df.to.model[1:round(nrow(df.to.model)*training_set_percentage/100),]
testing  <- df.to.model[-(1:round(nrow(df.to.model)*training_set_percentage/100)),]

nrow(testing) + nrow(training) == nrow(df.to.model)
```

Random forest

```{r}
ctrl <- trainControl(
    # powtórzona ocena krzyżowa
    method = "repeatedcv",
    # liczba podziałów
    number = 2,
    # liczba powtórzeń
    repeats = 5)

fit <- train(exposition ~ .,
             data = training,
             method = "rf",
             trControl = ctrl,
             # Paramter dla algorytmu uczącego
             ntree = 10)

fit

rfClasses <- predict(fit, newdata = testing)
confusionMatrix(data = rfClasses, testing$exposition)
```

Wagi dla klas


```{r}
model_weights <- as.numeric(training$exposition)
model_weights[training$exposition == -1] <- (1/table(training$exposition)[1]) * 0.5
model_weights[training$exposition == 0] <- (1/table(training$exposition)[2]) * 0.1
model_weights[training$exposition == 1] <- (1/table(training$exposition)[3]) * 0.4





```


```{}

ctrl <- trainControl(
    # powtórzona ocena krzyżowa
    method = "repeatedcv",
    # liczba podziałów
    number = 2,
    # liczba powtórzeń
    repeats = 5,
                     classProbs = TRUE)

weighted_fit <- train(exposition ~ .,
                      data = training,
                      method = "gbm",
                      verbose = FALSE,
                      weights = model_weights,
                      metric = "ROC",
                      trControl = ctrl)
fit <- train(exposition ~ .,
             data = training,
             method = "gbm",
             trControl = ctrl,
             weights = model_weights,
             # Paramter dla algorytmu uczącego
             ntree = 10)

fit

rfClasses <- predict(fit, newdata = testing)
confusionMatrix(data = rfClasses, testing$exposition)




```



