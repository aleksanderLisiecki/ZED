---
title: "Projekt ZED"
author: "Aleksander Lisiecki"
date: "`r format(Sys.time(), '%d %B %Y')`"
output: 
  html_document: 
    toc: yes
    toc_float:
      collapsed: yes
    toc_depth: 5
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(message = FALSE)
knitr::opts_chunk$set(warning = FALSE)
```

***
### Executive summary
***

Celem analizy jest interpretacja danych finansowych ceclem znalezienia wzorców wpływających na ceny różnych aktyw oraz wykonanie modelu potrafiącego zwrócić korzystne informacje dotyczące ceny złota.

Wśród danych znalazły się:

* kurs złota,
* wskaźniki rozwoju gospodarczego świata,
* dane dotyczące indeksu S&P Composite,
* kurs wymiany walut,
* dane z blockchainu Bitcoina,
* subiektywnie wyznaczone dobre momenty na kupno i sprzedaż złota.

W celu znalezienia możliwych korelacji w zbiorach dane zostały porównane ze sobą oraz sprawdzona została ich korelacja.
W analizie zawarte zostały:

* wizualizacja zmiany ludności w najliczniejszych krajach świata,
* ukazany został trend dotyczący samobójstw na świecie,
* zależność ceny złota do ceny Bitcoina,
* zależność ceny złota do ceny indeksu S&P Composite,
* 15 największych korelacji pomiędzy wskaźnikami największej gospodarki świata - USA, a ceną złota,

W sekcji poświęconej próbie predykcji korzystnych informacji dotyczących ceny złota stworzony został klasyfikator próbujący przewidzieć dobry moment na kupno i sprzedaż kruszcu.

***

Errata:

Błędy z ggplotly:

* w wynikowym HTML'u nie wyświetla się wykres samobójstw - w arkuszu .Rmd renderuje się on poprawnie,
* w animowanym i interaktywnym wykresie prezentującym zmianę ludności w najliczniejszych krajach świata w pewnych miejscach niektóre słupki wykonują dziwne nieprzewidziane przemieszczenia. Jest to błąd frameworka, ponieważ przy zmianie ilości wyświetlanych krajów błędy te występują w różnych miejscach (latach).

Błędy z kable_styling:

* w wynikowym HTML'u w niektórych tabelach widoczny jest kod html psujący czytelność - w arkuszu .Rmd tabele renderują się poprawnie.

***
### Użyte biblioteki
***

```{r}
library(dplyr)
library(plotly)
library(ggplot2)
library(readxl)
library(tidyr)
library(knitr)
library(kableExtra)
library(TTR)
library(data.table)
library(caret)
library(corrplot)
library(RColorBrewer)
library(randomForest)

set.seed(23)
```

***
### Gold Prices
***

#### Wczytywanie i czyszczenie danych

* nadanie właściwych typów danych,
* pozostawienie do dalszych rozważań jedynie ceny w walucie USD,
* zmiana nazw kolumn dla AM and PM fixing,

```{r, cache=TRUE}
Gold.prices <- read.csv("C:/Users/alili/Desktop/studia/9 semestr/ZED/projekt/Data pack/Gold prices.csv", 
                        colClasses = c(rep("Date", 1),
                                       rep("numeric", 2),
                                       rep("NULL", 4)),
                        col.names = c('Date',
                                      'Morning.Fix.USD',
                                      'Afternoon.Fix.USD',
                                      rep("NULL", 4)),
                        header = TRUE)
```

* uzupełnijnie brakujących wartości (NA) w kolumnach z ceną otwarcia i zamknięcia, wartością z sąsiedniej kolumny (w całym zbiorze nie ma sytuacji gdzie brakują obydwie)
* dodanie kolumny USD z uśrednioną ceną otwarcia i zamknięcia

```{r}
Gold.prices <- Gold.prices %>% 
  mutate(Morning.Fix.USD = coalesce(Morning.Fix.USD, Afternoon.Fix.USD),
         Afternoon.Fix.USD = coalesce(Afternoon.Fix.USD, Morning.Fix.USD),
         USD = (Morning.Fix.USD + Afternoon.Fix.USD) / 2)
```

* utworzenie zbioru ze średnią roczną ceną złota

```{r}
Gold.prices.yearly <- Gold.prices %>%
  mutate(Year = as.numeric(substr(Date, 1, 4))) %>%
  group_by(Year) %>% 
  summarize( USD = (mean(Morning.Fix.USD) + mean(Afternoon.Fix.USD)) / 2)
```


#### Podsumowanie danych

Zbiór zawiera codzienne wyceny złota podczas sesji otwarcia i zamknięcia od dnia 1968-01-02 do 2021-09-29.

```{r}
head(Gold.prices) %>% 
  kable() %>%
  kable_styling("striped", full_width = F, position = 'left')

data.frame(nrow(Gold.prices)) %>%
  rename("Liczba próbek" = 1) %>%
  kable() %>%
  kable_styling(full_width = FALSE, position = 'left')

summary(Gold.prices) %>%
  kable() %>%
  kable_styling("striped", full_width = F, position = 'left')
```

#### Analiza wartości ceny złota

Na interaktywnym wykresie widzimy zmianę cen otwarcia w czasie.

```{r, fig.width=9,fig.height=6}
p <- ggplot(Gold.prices, aes(x = Date)) +
  geom_line(aes(y = USD), color = "gold") + 
  theme_minimal()

ggplotly(p)
```

***
### World development indicators (WDI)
***

#### Wczytywanie zbioru danych

* podczas wczytywania uwzględniane są znaki wartości pustych w zbiorze
* pozbycie się informacji o źródle pochodzenia zbioru poprzez podanie zakresu czytania zbioru

```{r}
World_Development_Indicators <- read_excel("C:/Users/alili/Desktop/studia/9 semestr/ZED/projekt/Data pack/World_Development_Indicators.xlsx", 
                                           na = '..', 
                                           range = "A1:BC44305")
```

#### Czyszczenie zbioru

* usunięcie elementów innych niż kraje z kolumny `Country Name`, pozostawienie statystyk dla całego swiata w zbiorze krajów, 

```{r}
World_Development_Indicators <- World_Development_Indicators %>%
  filter(!`Country Name` %in% c("Low & middle income","Low income","Lower middle income","Middle income","Upper middle income","High income"))
```


* wyodrębnienie kodów serii do osobnej tabeli oraz usunięcie jej z przetwarzanego zbioru,
```{r}
World_Development_Indicators.Series_Codes <- select(World_Development_Indicators, `Series Name`, `Series Code`)
World_Development_Indicators <- select(World_Development_Indicators, -`Series Code`)
```

* przeniesienie pojedyńczych obserwacji do osobnych wierszy

```{r}
World_Development_Indicators <- World_Development_Indicators %>%
  pivot_longer(cols = `1970 [YR1970]`:`2020 [YR2020]`, names_to = "Year") %>%
  group_by(`Series Name`) %>%
  mutate(row = row_number()) %>%
  tidyr::pivot_wider(names_from = `Series Name`, values_from = value) %>%
  select(-row)
```

* poprawa kolumny Year: wyodrębnienie lat jako numerycznych wartości

```{r}
World_Development_Indicators <- World_Development_Indicators %>%
  mutate(Year = as.numeric(substr(Year, 1, 4)))
```

#### Podsumowanie danych

```{r}
country.count <- length(unique(World_Development_Indicators$`Country Name`)) - 1
indicators.count <- World_Development_Indicators %>%
  select(-`Country Name`, -`Country Code`, -Year) %>%
  ncol
  
WDI_summary <- data.frame(country.count, indicators.count) %>%
  rename("Liczba krajów" = country.count,
         "Liczba wskaźników" = indicators.count)

kable(WDI_summary) %>%
  kable_styling(full_width = FALSE, position = 'left')
```


:::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px; "}

::: {}

```{r, echo=FALSE}
World_Development_Indicators$`Country Name` %>%
  unique %>%
  data.frame() %>%
  rename('Lista krajów dostępnych w zbiorze' = '.') %>%
  kable() %>%
  kable_styling("striped", full_width = F, position = 'left') %>%
  scroll_box( height = '400px')
```

:::

::: {}

```{r, echo=FALSE}
World_Development_Indicators %>%
  names %>%
  data.frame() %>%
  rename('Lista dostępnych wskaźników' = '.') %>%
  kable %>%
  kable_styling("striped", full_width = F, position = 'left') %>%
  scroll_box(width = '650px', height = '400px')
```

:::

::::



***
### S&P Composite
***

#### Wczytywanie danych

```{r}
SP.Composite <- read.csv("C:/Users/alili/Desktop/studia/9 semestr/ZED/projekt/Data pack/S&P Composite.csv")
```

#### Czyszczenie danych

* zmiana nazwy oraz typ na właściwy kolumny z datą
* zmiana nazwy Cyclicaly.Adjusted.PE.Ratio na skrót CAPE -

```{r}
SP.Composite <- SP.Composite %>%
  rename(Date = Year,
         CAPE = Cyclically.Adjusted.PE.Ratio) %>%
  mutate(Date = as.Date(Date))
```

#### Znaczenie atrybutów

* S.P.Composite - nominalna wartość indexu,
* Divident - nominalna dywidenta,
* Earnings - nominalne zarobki na indeksie,
* CPI - wskaźnik cen towarów i usług konsumpcyjnych. Najpopularniejsza na świecie miara inflacji/deflacji,
* Long.Interest.Rate - stopy procentowe dziesięcioletnich obligacji rządowych,
* Real.Price - realna wartość indexu,
* Real.Divident - realna dywidenta,
* Real.Earnings - realne zarobki na indeksie,
* CAPE (Cyclicaly.Adjusted.PE.Ratio) - cyklicznie dostosowywany wskaźnik ceny do zysków. Definiuje się go jako cenę podzieloną przez średnią z dziesięciu lat zarobków, skorygowaną o inflację.

```{r}
plot.data_SP.Composite <- SP.Composite %>% 
  pivot_longer(2:10) %>% 
  filter(!is.na(value))

plot.data_SP.Composite %>% 
  ggplot(aes(x = Date, y = value)) + 
  geom_line() +
  facet_wrap(name ~ ., scales="free", ncol = 3) +
  theme_minimal()
```


#### Podsumowanie danych

```{r}
head(SP.Composite) %>% 
  kable() %>%
  kable_styling("striped", full_width = F, position = 'left') %>%
  scroll_box( width = '100%')

data.frame(nrow(Gold.prices)) %>%
  rename("Liczba próbek" = 1) %>%
  kable() %>%
  kable_styling(full_width = FALSE, position = 'left')

summary(SP.Composite) %>%
  kable() %>%
  kable_styling(bootstrap_options = c("striped", "hover"), position = 'left') %>%
  scroll_box( width = '100%')
```

***
### Currency Exchange Rates
***

#### Wczytywanie danych

```{r, cache=TRUE}
Currency.Exchange.Rates <- read.csv("C:/Users/alili/Desktop/studia/9 semestr/ZED/projekt/Data pack/CurrencyExchangeRates.csv")
```

#### Czyszczenie danych

* zmiana typu kolumny z datą

```{r}
Currency.Exchange.Rates <- Currency.Exchange.Rates %>% 
  mutate(Date = as.Date(Date))
```

#### Podsumowanie danych

Zbiór zawiera codzienny kurs wymiany walut od dnia 1995-01-02 do 2018-05-02.

```{r}
Currency.Exchange.Rates %>%
  names %>%
  data.frame() %>%
  rename('Dostępne waluty' = '.') %>%
  kable %>%
  kable_styling("striped", full_width = F, position = 'left') %>%
  scroll_box(width = '400px', height = '400px')
```

***
### Bitcoin dataset
***

#### Wczytywanie danych

```{r, cache=TRUE}
Bitcoin.prices <- read.csv("C:/Users/alili/Desktop/studia/9 semestr/ZED/projekt/Data pack/Bitcoin/BCHAIN-MKPRU.csv",
                           colClasses = c(rep("Date", 1),
                                       rep("numeric", 1)),
                           col.names = c('Date',
                                      'USD'))

Bitcoin.trade.volume <- read.csv("C:/Users/alili/Desktop/studia/9 semestr/ZED/projekt/Data pack/Bitcoin/BCHAIN-TRVOU.csv",
                           colClasses = c(rep("Date", 1),
                                       rep("numeric", 1)),
                           col.names = c('Date',
                                      'Trade Volume'))

Bitcoin.mine.difficulty <- read.csv("C:/Users/alili/Desktop/studia/9 semestr/ZED/projekt/Data pack/Bitcoin/BCHAIN-DIFF.csv",
                           colClasses = c(rep("Date", 1),
                                       rep("numeric", 1)),
                           col.names = c('Date',
                                      'Mine difficulty'))

Bitcoin.hash.rate <- read.csv("C:/Users/alili/Desktop/studia/9 semestr/ZED/projekt/Data pack/Bitcoin/BCHAIN-HRATE.csv",
                           colClasses = c(rep("Date", 1),
                                       rep("numeric", 1)),
                           col.names = c('Date',
                                      'Hash rate'))
Bitcoin <- Bitcoin.prices %>%
  merge(Bitcoin.trade.volume, by = "Date") %>%
  merge(Bitcoin.mine.difficulty, by = "Date") %>%
  merge(Bitcoin.hash.rate, by = "Date")
  
```


#### Podsumowanie danych

Zestaw danych zawiera codzienne informacje od początku istnienia Bitcoina.

Znaczenie atrybutów:
* USD - Bitcoin Market Price USD,Average USD market price across major bitcoin exchanges.
* Trade volume - Bitcoin USD Exchange Trade Volume,The total USD value of trading volume on major bitcoin exchanges.
* Mine difficulty - Bitcoin Difficulty,A relative measure of how difficult it is to find a new block. The difficulty is adjusted periodically as a function of how much hashing power has been deployed by the network of miners.
* Hash rate - Bitcoin Hash Rate,The estimated number of tera hashes per second (trillions of hashes per second) the Bitcoin network is performing.




```{r}
tail(Bitcoin) %>%
  kable %>%
  kable_styling("striped", full_width = F, position = 'left') 

summary(Bitcoin) %>%
  kable %>%
  kable_styling("striped", full_width = F, position = 'left')
```


***
***

### Analizy

***

#### Animowany wykres zmiany liczby ludności w czasie 

Odpalić z puszczoną w tle piosenką "Another One Bites the Dust" zespołu Queen.

```{r, cache = TRUE, echo=FALSE, message=FALSE, warning=FALSE, fig.width=9,fig.height=6}
specify_decimal <- function(x, k) trimws(format(round(x, k), nsmall=k))

World.Population.Top10 <- World_Development_Indicators %>%
  filter(`Country Name` != "World") %>%
  rename(Population = `Population, total`) %>%
  select(`Country Name`, Year, Population) %>%
  group_by(Year) %>%
  arrange(desc(Population), .by_group = T) %>%
  top_n(11) %>%
  mutate(`Population in mln` = Population/10^6, Rank = rank(Population))

p <- World.Population.Top10 %>%
  ggplot(aes(Rank, Population, fill = `Country Name`)) +
  geom_col(aes(frame = Year), position = "identity") +
  geom_text(aes(frame = Year, y = Population + 1.5*10^8, label = paste0(round(`Population in mln`,2), 'mln')), hjust = 0) +
  geom_text(aes(frame = Year, y = `Population in mln`/2, label = `Country Name`), hjust = 0) +
  ylim(-10^8,1.6*10^9) +
  coord_flip() +
  theme_minimal() +
  ggtitle("Populacja świata w latach 1970-2020") +
  theme(axis.line=element_blank(),
        axis.text.x=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        legend.position="none") 

ggplotly(p)
```

***

#### Samobójstwa kobiet i mężczyzn na świecie w latach 2000-2019

```{r}

suicides <- World_Development_Indicators %>%
  filter(`Country Name` == 'World') %>%
  select(Year, `Suicide mortality rate, female (per 100,000 female population)`, `Suicide mortality rate, male (per 100,000 male population)`) %>%
  filter(!is.na(`Suicide mortality rate, female (per 100,000 female population)`))

suicides.male <- suicides %>%
  select(Year, `Suicide mortality rate, male (per 100,000 male population)`) %>%
  rename(`Suicide mortality rate (per 100,000 of given gender population)` = `Suicide mortality rate, male (per 100,000 male population)`) %>%
  mutate(gender = 'male')

suicides.female <- suicides %>%
  select(Year, `Suicide mortality rate, female (per 100,000 female population)`) %>%
  rename(`Suicide mortality rate (per 100,000 of given gender population)` = `Suicide mortality rate, female (per 100,000 female population)`) %>%
  mutate(gender = 'female')

suicides.per.gender <- rbind.data.frame(suicides.male, suicides.female)

p <- suicides.per.gender %>%
  ggplot(aes(x = Year, y = `Suicide mortality rate (per 100,000 of given gender population)`)) +
  geom_line(aes(colour = gender), size = 1) +
  geom_point(colour = 'royalblue', size = 2) +
  expand_limits(y = 0) +
  ggtitle('Współczynnik samobójstw (na 100,000 osób danej płci)') +
  ylab('') +
  theme_minimal()

ggplotly(p)
```

Wniosek: 
Liczba samobójstw na świecie spada. 

***

#### Korelacja ceny złota do ceny BTC

```{r}
gold <- Gold.prices %>%
  select(Date, USD) %>%
  arrange(desc(row_number())) %>%
  filter( Date < '2021-09-29') %>%
  filter( Date > '2016-01-01') %>%
  rename( USD.gold = USD )

BTC_price <- Bitcoin.prices %>%
  arrange(desc(row_number())) %>%
  filter( Date < '2021-09-29') %>%
  filter( Date > '2016-01-01') %>%
  rename( USD.BTC = USD )

gold.btc <- gold %>%
  inner_join(BTC_price, by = 'Date')

print(paste("Korelacja złota z ceną Bitcoina: ", round(cor(gold.btc$USD.gold, gold.btc$USD.BTC, use = "complete.obs"))))

coeff.gold.btc <- max(gold.btc$USD.BTC)/max(gold.btc$USD.gold)

gold.btc %>%
  ggplot( aes(x = Date) ) +
  geom_line( aes(y = USD.gold), color = 'gold' ) +
  geom_line( aes(y = USD.BTC/coeff.gold.btc), color = 'orange' ) + 
  scale_y_continuous(
    name = "Cena złota",
    sec.axis = sec_axis(~.*coeff.gold.btc, name="Cena BTC")
  ) +
  ggtitle("Cena złota oraz BTC [USD]") +
  theme_minimal() + 
  theme(
    axis.title.y = element_text(color = 'gold', size=13),
    axis.title.y.right = element_text(color = 'orange', size=13),
    axis.text.y = element_text(color = 'gold', size=13),
    axis.text.y.right = element_text(color = 'orange', size=13)
  )
```

Wniosek:
Pomimo korelacji na poziomie 0.68 wizualna inspekcja nie pokazuje jasnej zależności pomiędzy cenami porównywanych aktywów.


#### Korelacja złota z indexem S&P Composite

```{r}
Gold.prices.monthly <- Gold.prices %>%
  mutate(Date = substr(Date, 1, 7)) %>%
  group_by(Date) %>% 
  summarize( USD = (mean(Morning.Fix.USD) + mean(Afternoon.Fix.USD)) / 2)

SP.df <- SP.Composite %>%
  mutate(Date = substr(Date, 1, 7)) %>%
  select(Date, S.P.Composite)

gold.SP <- Gold.prices.monthly %>%
  inner_join(SP.df, by = 'Date') %>%
  mutate(Date = as.Date(paste0(Date,'-01')))

print(paste("Korelacja złota z indeksem S&P Composite: ", round(cor(gold.SP$USD, gold.SP$S.P.Composite, use = "complete.obs"), 2)))

coeff.gold.SP <- max(gold.SP$S.P.Composite)/max(gold.SP$USD)

gold.SP %>%
  ggplot( aes(x = Date) ) +
  geom_line( aes(y = USD), color = 'gold' ) +
  geom_line( aes(y = S.P.Composite/coeff.gold.SP), color = 'royalblue' ) + 
  scale_y_continuous(
    name = "Cena złota",
    sec.axis = sec_axis(~.*coeff.gold.SP, name="Cena S&P Composite")
  ) +
  ggtitle("Cena złota oraz indeksu S&P Composite [USD]") +
  theme_minimal() + 
  theme(
    axis.title.y = element_text(color = 'gold', size=13),
    axis.title.y.right = element_text(color = 'royalblue', size=13),
    axis.text.y = element_text(color = 'gold', size=13),
    axis.text.y.right = element_text(color = 'royalblue', size=13)
  )
```

Wniosek:
Pomimo korelacji na poziomie 0.82 wizualna inspekcja nie pokazuje jasnej zależności pomiędzy cenami porównywanych aktywów.

***

#### Zbadanie najwyższych korelacji wskaźników rozwoju USA z ceną złota

```{r}
USA.WDI <- World_Development_Indicators %>%
  filter(`Country Name` == 'United States') %>%
  merge(Gold.prices.yearly, by = 'Year') %>%
  select_if(~ !any(is.na(.)))
  
USA.WDI.to_cor <- USA.WDI %>%
  select(-(1:3))

num_col=ncol(USA.WDI.to_cor[,-1])
out_indx <-  which(upper.tri(diag(num_col))) 
cor_cols <- USA.WDI.to_cor  %>%
            do(melt(cor(.[,-1], use="pairwise.complete.obs"), value.name="cor")[out_indx,])

cor_cols <- cor_cols %>%
  filter(Var2 == 'USD') %>%
  top_n(15) %>%
  arrange(desc(cor)) %>%
  rename("top correlations" = cor)

cor_cols %>%
  kable %>%
  kable_styling("striped", full_width = F, position = 'left')%>%
  scroll_box(width = '100%')
```


```{r}
cor_cols %>% ggplot(aes(x = reorder(Var1, `top correlations`), 
                        y = `top correlations`,
                        label = sprintf("%0.2f", round(`top correlations`, digits = 2)))) +
  geom_bar(position=position_dodge(), stat="identity",  colour="darkgrey", fill = 'lightgrey', width = 0.5) +
  geom_text(size = 3, hjust = 1.2) +
  theme_minimal() +
  coord_flip() +
  theme(axis.title = element_blank()) +
  ggtitle("Top 15 korelacji złota z wskaźnikami WDI USA ")
```

Wnioski:

Wskaźniki, które mają najwyższą korelację z ceną złota wskazują raczej na ogólny wzrost godspodarczy.



```{r}
coeff.income_gold.price <- max(USA.WDI$`Net primary income (BoP, current US$)`)/max(USA.WDI$USD)

USA.WDI %>%
  ggplot( aes(x = Year) ) +
  geom_line( aes(y = USD), color = 'gold' ) +
  geom_line( aes(y = `Net primary income (BoP, current US$)`/coeff.income_gold.price), color = 'royalblue' ) + 
  scale_y_continuous(
    name = "Cena złota",
    sec.axis = sec_axis(~.*coeff.gold.SP, name="Net primary income")
  ) +
  ggtitle("Cena złota w porównaniu ze wskaźnikiem przychodu netto w USA") +
  theme_minimal() + 
  theme(
    axis.title.y = element_text(color = 'gold', size=13),
    axis.title.y.right = element_text(color = 'royalblue', size=13),
    axis.text.y = element_text(color = 'gold', size=13),
    axis.text.y.right = element_text(color = 'royalblue', size=13)
  )
```

```{r}
coeff.service_export.price <- max(USA.WDI$`Service exports (BoP, current US$)`)/max(USA.WDI$USD)

USA.WDI %>%
  ggplot( aes(x = Year) ) +
  geom_line( aes(y = USD), color = 'gold' ) +
  geom_line( aes(y = `Service exports (BoP, current US$)` / coeff.service_export.price), color = 'royalblue' ) + 
  scale_y_continuous(
    name = "Cena złota",
    sec.axis = sec_axis(~.*coeff.gold.SP, name="Service exports")
  ) +
  ggtitle("Cena złota w porównaniu ze wskaźnikiem eksportu usług w USA") +
  theme_minimal() + 
  theme(
    axis.title.y = element_text(color = 'gold', size=13),
    axis.title.y.right = element_text(color = 'royalblue', size=13),
    axis.text.y = element_text(color = 'gold', size=13),
    axis.text.y.right = element_text(color = 'royalblue', size=13)
  )
```

Wnioski: 

Wskaźniki WDI są podawane rok rocznie. 
Uważamy, że próba przewidywania ceny złota w ujęciu rocznym ze względu na zbyt małą ilość danych nie będzie wartościowa. Zamiast prób tworzenia regresora przewidującego cenę złota spróbujemy przewidzieć dobry moment na kupno i sprzedaż kruszcu opierając się o wskaźniki analizy technicznej.

***

### Klasyfikator

Zamiast przewidywać cenę złota stworzymy model próbujący znaleźć we wskaźnikach analizy technicznej dobre momenty do kupna lub sprzedaży złota.

Próba oparta bedzie o strategię średnich kroczących (ang. moving averages - MA). Metoda ta polega na obliczeniu średniej ceny złota z okresu czasu o długości N wstecz. 

Poza prostymi średnimi kroczącymi (ang. simple moving averages - SMA) wykorzystana jest również wykładnicza średnia krocząca (ang. exponential moving average - EMA). EMA różni się od SMA tym, że podczas obliczania średniej na wartości nakładane są wykładnicze wagi, które maleją wraz z odległością próbki. 

Średnie kroczące pozwalają na wygładzenie szumu z szeregów cenowych uwydatniając w ten sposób trendy. 
Na podstawie wielu średnich kroczących można spróbować określić dobry moment kupna lub sprzedaży patrząc na ich miejsca przecinania.

#### Przygotowanie danych

##### Zaznaczanie miejsc dobrych do kupna i sprzedaży

Pierwszym krokiem jest ręczne zaznaczenie okresów w których warto było poszerzać lub zawężać ekspozycję swojego portfela inwestycyjnego na złoto. 

##### Odczytanie zbioru z miejscami kupna/sprzedaży

```{r}
Gold.prices <- read_excel("C:/Users/alili/Desktop/studia/9 semestr/ZED/projekt/Data pack/Gold_prices_with_marked_exposition.xlsx")
```

##### Czyszczenie zbioru

* wyodrębnienie miejsc kupna i sprzedaży do osobnych kolumn

```{r}

positive.exposition <- Gold.prices$exposition
positive.exposition[Gold.prices$exposition == -1] <- 0

negative.exposition <- Gold.prices$exposition
negative.exposition[Gold.prices$exposition == 1] <- 0
negative.exposition[Gold.prices$exposition == -1] <- 1

Gold.prices <- Gold.prices %>%
  mutate('positive.exposition' = positive.exposition,
         'negative.exposition' = negative.exposition,)

```

##### Wykres przedstawiający miejsca kupna oraz sprzedaży

```{r, echo = FALSE}
positive.diff <- diff(c(0, positive.exposition))
positive.starts <- Gold.prices$Date[positive.diff == 1]
positive.ends <- Gold.prices$Date[positive.diff == -1]
if (length(positive.starts) > length(positive.ends)) positive.ends <- c(positive.ends, tail(Gold.prices$Date, 1))

positive.sections <- data.frame(start=positive.starts, end=positive.ends, group=seq_along(positive.starts))

negative.diff <- diff(c(0, negative.exposition))
negative.starts <- Gold.prices$Date[negative.diff == 1]
negative.ends <- Gold.prices$Date[negative.diff == -1]
if (length(negative.starts) > length(negative.ends)) negative.ends <- c(negative.ends, tail(Gold.prices$Date, 1))

negative.sections <- data.frame(start=negative.starts, end=negative.ends, group=seq_along(negative.starts))

ggplot(data=Gold.prices, aes(Date, USD)) +
  theme_minimal() +
  ggtitle("Miejsca kupna oraz sprzedaży złota") +
  geom_line(color = "gold") +
  geom_rect(data=positive.sections, inherit.aes=FALSE, aes(xmin=start, xmax=end, ymin=min(Gold.prices$value),
                ymax=max(Gold.prices$value), group=group), color="transparent", fill="green", alpha=0.4)+
  geom_rect(data=negative.sections, inherit.aes=FALSE, aes(xmin=start, xmax=end, ymin=min(Gold.prices$value),
                ymax=max(Gold.prices$value), group=group), color="transparent", fill="red", alpha=0.4)

```

##### Podsumowanie ilości dni dobrych do kupna oraz sprzedaży złota

```{r}
positive.exposition.count <- data.frame(positive.exposition) %>%
  filter(positive.exposition > 0) %>%
  count() %>%
  rename("positive exposition" = n)

negative.exposition.count <- data.frame(negative.exposition) %>%
  filter(negative.exposition > 0) %>%
  count() %>%
  rename("negative exposition" = n)

data.frame(nrow(Gold.prices) , positive.exposition.count, negative.exposition.count) %>%
  rename("liczba próbek" = 1,
         "positive exposition" = 2,
         "negative exposition" = 3) %>%
  kable %>%
  kable_styling("striped", full_width = F, position = 'left')
```

Liczba miejsc do kupna jest znacznie wieksza niż miejsc do sprzedaży. Jest to spowodowane tym, że wzrost wartości złota jest powolny i jest więcej okazji do kupna, a spadki szybkie, napędzane emocjami inwestorów.

Poza tym widać, że zbiór jest niezbalansowany.


##### Obliczanie średnich kroczących

```{r}
Gold.prices.with.MA <- Gold.prices %>%
  arrange(desc(row_number())) %>%
  mutate(MA3 = SMA(USD, 3),
         MA7 = SMA(USD, 7),
         EMA13 = EMA(USD, 13),
         MA19 = SMA(USD, 19),
         MA50 = SMA(USD, 50),
         MA200 = SMA(USD, 200),
         MA1095 = SMA(USD, 1095)
         ) %>%
  filter_at(vars(-Date), all_vars(!is.na(.))) 

head(Gold.prices.with.MA) %>% 
  kable() %>%
  kable_styling("striped", full_width = F, position = 'left') %>%
  scroll_box(width = '100%')
  
```

Mmmm, jaki piękny zbiór na wykonanie modelu... już nie mogę się doczekać :3

##### Wykres prezentujący średnie kroczące we fragmencie kursu złota. 

```{r, echo = FALSE}
plot.df <- Gold.prices.with.MA %>%
  filter(Date > "2017-01-01") %>%
  filter(Date < "2019-01-01")

ggplot(data = plot.df, aes(Date)) +
  theme_minimal() +
  ggtitle("EMA13 oraz MA19 nałożone na wykres złota") +
  geom_line(aes(y=USD), color = "gold") +
  geom_line(aes(y=EMA13), color = "blue") +
  geom_line(aes(y=MA19), color = "black") 

```

Na wykresie zauważyć można punkty przecięcia średnich kroczących, które sugerować mogą podjęcie operacji na rynku.

***

#### Klasyfikator

##### Podzielenie zbioru na zbiór treningowy oraz testowy

Zbiór jest dzielony wedle chronologii próbek, nie w sposób losowy, aby zbiór testowy nie był podobny do zbioru treningowego.

```{r}
training_set_percentage <- 80

model.df <- Gold.prices.with.MA %>%
  select(-(Date:USD), -positive.exposition, -negative.exposition) %>%
  mutate(exposition = as.factor(exposition))

training <- model.df[1:round(nrow(model.df)*training_set_percentage/100),]
testing  <- model.df[-(1:round(nrow(model.df)*training_set_percentage/100)),]

stopifnot(nrow(testing) + nrow(training) == nrow(model.df))
```

##### Stworzenie klasyfikatora

```{r}
set.seed(23)

seeds <- vector(mode = "list", length = 26)
for(i in 1:25) seeds[[i]] <- sample.int(n=1000, 3)
seeds[[26]] <- sample.int(n=1000, 1)

ctrl <- trainControl(seeds = seeds)

fit <- train(exposition ~ .,
             data = training,
             method = "rf",
             trControl = ctrl,
             ntree = 20)

rfClasses <- predict(fit, newdata = testing)
confusionMatrix(data = rfClasses, testing$exposition)
```

##### Wnioski 

Wyniki modelu są obiecujące, choć początkowo na to nie wskazują. 

* Accuracy (dokładność) modelu jest na poziomie 60%.
* Sensitivity (wrażliwość, czułość - wskaźnik wartości True Positive) przedziały czau w których warto było kupować były duże. Klasyfikator może wskazywać znacznie węższe przedziały i niskie wartosci dla klas kupna i sprzedaży w tym przypadku nie muszą oznaczać klasyfikatora niskiej jakości.
* Specificity (specyficzność - wskaźnik wartości True Negative) klas sprzedaży oraz kupna jest bardzo wysokie co oznacza, że klasyfikator nie często myli się podczas predykcji tych miejsc - jest to dobry sygnał.
* z macierzy pomyłek odczytać można, że model nie myli się pomiędzy klasami kupno-sprzedaż 

Wynik modelu najlepiej będzie ocenić wizualnie wyświetlając miejsca, które model wskazał jako dobre do kupna lub sprzedaży.

##### Ważność atrybutów

```{r}
indicators.importance <- data.frame(importance(fit$finalModel)) %>%
  mutate(names = rownames(.))

indicators.importance %>%
  ggplot(aes(x = reorder(names, -MeanDecreaseGini), 
             y = MeanDecreaseGini)) +
  geom_col() +
  labs(x = "Atrybuty", y = "Ważność atrybutu") +
  ggtitle("Ważności atrybutów") +
  theme_minimal()

```

Model największą wagę przywiązuje do średnich kroczących z dłuższego okresu. Średnie liczone na dłuższym okresie bardziej wygładzają wykres i pokazują ogólny trend zachodzący w kursie. Przecięcia średnich krótszego okresu ze średnimi dłuższego okredu definitywnie pokazują zmianę trendu. Poleganie tylko na średnich długiego okresu nie jest dobre, ponieważ wraz z zwiększaniem okresu liczenia średniej wzrasta opóźnienie ich reakcji w stosunku do zmiany kursu.

##### Wizualizacja predykcji 


```{r, echo = FALSE}
# predictions 
df <- Gold.prices.with.MA %>%
  mutate(prediction = predict(fit, newdata = Gold.prices.with.MA)) %>%
  tail(nrow(testing))

positive.prediction <- df$prediction
positive.prediction[df$prediction == -1] <- 0

negative.prediction <- df$prediction
negative.prediction[df$prediction == 1] <- 0
negative.prediction[df$prediction == -1] <- 1

df <- df %>%
  mutate('positive.prediction' = positive.prediction,
         'negative.prediction' = negative.prediction,)

positive.prediction.diff <- diff(c(0, positive.prediction))
positive.prediction.starts <- df$Date[positive.prediction.diff == 1]
positive.prediction.ends <- df$Date[positive.prediction.diff == -1]
if (length(positive.prediction.starts) > length(positive.prediction.ends)) positive.prediction.ends <- c(positive.prediction.ends, tail(df$Date, 1))

positive.prediction.sections <- data.frame(start=positive.prediction.starts, end=positive.prediction.ends, group=seq_along(positive.prediction.starts))


negative.prediction.diff <- diff(c(0, negative.prediction))
negative.prediction.starts <- df$Date[negative.prediction.diff == 1]
negative.prediction.ends <- df$Date[negative.prediction.diff == -1]
negative.prediction.ends <- negative.prediction.ends[-1]
if (length(negative.prediction.starts) > length(negative.prediction.ends)) negative.prediction.ends <- c(negative.prediction.ends, tail(df$Date, 1))

negative.prediction.sections <- data.frame(start=negative.prediction.starts, end=negative.prediction.ends, group=seq_along(negative.prediction.starts))



ggplot(data=df, aes(Date, USD)) +
  theme_minimal() +
  geom_line(color = "gold") +
  ggtitle("Miejsca kupna oraz sprzedaży złota wskazane przez model") +
  geom_rect(data=positive.prediction.sections, inherit.aes=FALSE, aes(xmin=start, xmax=end, ymin=min(df$USD),
                ymax=max(df$USD), group=group), color="transparent", fill="green", alpha=0.4)+
  geom_rect(data=negative.prediction.sections, inherit.aes=FALSE, aes(xmin=start, xmax=end, ymin=min(df$USD),
                ymax=max(df$USD), group=group), color="transparent", fill="red", alpha=0.4)

```



```{r, echo = FALSE}
# train set
df <- Gold.prices %>%
  arrange(desc(row_number())) %>%
  tail(nrow(testing))

positive.exposition <- df$exposition
positive.exposition[df$exposition == -1] <- 0

negative.exposition <- df$exposition
negative.exposition[df$exposition == 1] <- 0
negative.exposition[df$exposition == -1] <- 1

df <- df %>%
  mutate('positive.exposition' = positive.exposition,
         'negative.exposition' = negative.exposition,)

positive.diff <- diff(c(0, positive.exposition))
positive.starts <- df$Date[positive.diff == 1]
positive.ends <- df$Date[positive.diff == -1]
if (length(positive.starts) > length(positive.ends)) positive.ends <- c(positive.ends, tail(Gold.prices$Date, 1))

positive.sections <- data.frame(start=positive.starts, end=positive.ends, group=seq_along(positive.starts))


negative.diff <- diff(c(0, negative.exposition))
negative.starts <- df$Date[negative.diff == 1]
negative.ends <- df$Date[negative.diff == -1]
if (length(negative.starts) > length(negative.ends)) negative.ends <- c(negative.ends, tail(Gold.prices$Date, 1))

negative.sections <- data.frame(start=negative.starts, end=negative.ends, group=seq_along(negative.starts))


ggplot(data=df, aes(Date, USD)) +
  theme_minimal() +
  ggtitle("Porównanie zbioru testowego z predykcjami klasyfikatora") +
  geom_line(color = "gold") +
  geom_rect(data=positive.prediction.sections, inherit.aes=FALSE, aes(xmin=start, xmax=end, ymin=min(df$USD),
                ymax=min(df$USD)+(max(df$USD)-min(df$USD))/2, group=group), color="transparent", fill="green", alpha=0.4)+
  geom_rect(data=negative.prediction.sections, inherit.aes=FALSE, aes(xmin=start, xmax=end, ymin=min(df$USD),
                ymax=min(df$USD)+(max(df$USD)-min(df$USD))/2, group=group), color="transparent", fill="red", alpha=0.4)+
  geom_rect(data=positive.sections, inherit.aes=FALSE, aes(xmin=start, xmax=end, ymin=min(df$USD)+(max(df$USD)-min(df$USD))/2,
                ymax=max(df$USD), group=group), color="transparent", fill="green", alpha=0.4)+
  geom_rect(data=negative.sections, inherit.aes=FALSE, aes(xmin=start, xmax=end, ymin=min(df$USD)+(max(df$USD)-min(df$USD))/2,
                ymax=max(df$USD), group=group), color="transparent", fill="red", alpha=0.4) +
  geom_hline(yintercept = min(df$USD)+(max(df$USD)-min(df$USD))/2) +
  geom_label(inherit.aes=FALSE,
             aes(
               label = "Predykcja klasyfikatora",
               x = as.POSIXct('2015-03-01'),
               y = 1500,
               vjust = 'center'
               )
             ) +
  geom_label(inherit.aes=FALSE,
             aes(
               label = "Wartości testowe",
               x = as.POSIXct('2015-03-01'),
               y = 1625,
               vjust = 'center'
               )
             ) 
             
```

Wnioski:

Model jest bardzo zachowawczy w swoich decyzjach i niepewnie decyduje się na inwestycje (pewnie z uwagi na duże przeuczenie - zauważone na sam koniec), jednak gdy już to zrobi robi to przeważnie trafnie. 
Model wykazuje również tendencję do akumulacji aktywa i niechętnie je odsprzedaje.

Metoda średnich kroczących nie jest skutecznym narzędziem podczas konsolidacji rynku.
Zauważyć można, że model w momencie konsolidacji występującej w latach (około 2014 - 2019) nie popełnia wielu błędów i raczej ją przeczekał dokupując na dołkach. Sugeruje to potencjalnie wyższą skuteczność niż tradycyjna metoda.

Utrudnieniem dla klasyfikatora jest fakt, że w ostatnich latach nastąpił znacznie większy ruch kursu złota w porównaniu do lat na których klasyfikator był uczony.

Z eksperymentu widać, że zaproponowana metoda uczenia modelu znajdowania wzorców we wskaźnikach analizy technicznej zapowiada się obiecująco i w dalszych pracach można skupić się na dostrojeniu parametrów modelu oraz poszerzyć wachlarz dostępnych wskaźników. Zastanowić się również można nad dokładniejszym oznaczeniu miejsc kupna i sprzedaży.


```{r, echo = FALSE}
# predictions 
df <- Gold.prices.with.MA %>%
  mutate(prediction = predict(fit, newdata = Gold.prices.with.MA))

positive.prediction <- df$prediction
positive.prediction[1] <- 1
positive.prediction[df$prediction == -1] <- 0

negative.prediction <- df$prediction
negative.prediction[1] <- 0
negative.prediction[df$prediction == 1] <- 0
negative.prediction[df$prediction == -1] <- 1

df <- df %>%
  mutate('positive.prediction' = positive.prediction,
         'negative.prediction' = negative.prediction,)

positive.prediction.diff <- diff(c(0, positive.prediction))
positive.prediction.starts <- df$Date[positive.prediction.diff == 1]
positive.prediction.ends <- df$Date[positive.prediction.diff == -1]

positive.prediction.ends <- positive.prediction.ends[-1]

if (length(positive.prediction.starts) > length(positive.prediction.ends)) positive.prediction.ends <- c(positive.prediction.ends, tail(df$Date, 1))

positive.prediction.sections <- data.frame(start=positive.prediction.starts, end=positive.prediction.ends, group=seq_along(positive.prediction.starts))


negative.prediction.diff <- diff(c(0, negative.prediction))
negative.prediction.starts <- df$Date[negative.prediction.diff == 1]
negative.prediction.ends <- df$Date[negative.prediction.diff == -1]
if (length(negative.prediction.starts) > length(negative.prediction.ends)) negative.prediction.ends <- c(negative.prediction.ends, tail(df$Date, 1))

negative.prediction.sections <- data.frame(start=negative.prediction.starts, end=negative.prediction.ends, group=seq_along(negative.prediction.starts))

# train set
df <- Gold.prices %>%
  arrange(desc(row_number()))

positive.exposition <- df$exposition
positive.exposition[df$exposition == -1] <- 0

negative.exposition <- df$exposition
negative.exposition[df$exposition == 1] <- 0
negative.exposition[df$exposition == -1] <- 1

df <- df %>%
  mutate('positive.exposition' = positive.exposition,
         'negative.exposition' = negative.exposition,)

positive.diff <- diff(c(0, positive.exposition))
positive.starts <- df$Date[positive.diff == 1]
positive.ends <- df$Date[positive.diff == -1]
if (length(positive.starts) > length(positive.ends)) positive.ends <- c(positive.ends, tail(Gold.prices$Date, 1))

positive.sections <- data.frame(start=positive.starts, end=positive.ends, group=seq_along(positive.starts))

negative.diff <- diff(c(0, negative.exposition))
negative.starts <- df$Date[negative.diff == 1]
negative.ends <- df$Date[negative.diff == -1]
if (length(negative.starts) > length(negative.ends)) negative.ends <- c(negative.ends, tail(Gold.prices$Date, 1))

negative.sections <- data.frame(start=negative.starts, end=negative.ends, group=seq_along(negative.starts))

ggplot(data=df, aes(Date, USD)) +
  theme_minimal() +
  ggtitle("Porównanie całego zbioru z predykcjami klasyfikatora") +
  geom_line(color = "gold") +
  geom_rect(data=positive.prediction.sections, inherit.aes=FALSE, aes(xmin=start, xmax=end, ymin=min(df$USD),
                ymax=min(df$USD)+(max(df$USD)-min(df$USD))/2, group=group), color="transparent", fill="green", alpha=0.4)+
  geom_rect(data=negative.prediction.sections, inherit.aes=FALSE, aes(xmin=start, xmax=end, ymin=min(df$USD),
                ymax=min(df$USD)+(max(df$USD)-min(df$USD))/2, group=group), color="transparent", fill="red", alpha=0.4)+
  geom_rect(data=positive.sections, inherit.aes=FALSE, aes(xmin=start, xmax=end, ymin=min(df$USD)+(max(df$USD)-min(df$USD))/2,
                ymax=max(df$USD), group=group), color="transparent", fill="green", alpha=0.4)+
  geom_rect(data=negative.sections, inherit.aes=FALSE, aes(xmin=start, xmax=end, ymin=min(df$USD)+(max(df$USD)-min(df$USD))/2,
                ymax=max(df$USD), group=group), color="transparent", fill="red", alpha=0.4) +
  geom_hline(yintercept = min(df$USD)+(max(df$USD)-min(df$USD))/2) +
  geom_label(inherit.aes=FALSE,
             aes(
               label = "Predykcja klasyfikatora",
               x = as.POSIXct('1975-01-01'),
               y = 880,
               vjust = 'center'
               )
             ) +
  geom_label(inherit.aes=FALSE,
             aes(
               label = "Zbiór uczący + testowy",
               x = as.POSIXct('1975-01-01'),
               y = 1200,
               vjust = 'center'
               )
             ) 
             
```

Na tej wizualizacji widać przeuczenie modelu, które z uwagi na brak czasu nie zostało poprawione.
